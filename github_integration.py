"""
GitHub Integration Module for Nexus API
Handles OAuth, Repository Creation, and One-Click Deploy
"""
import os
import json
import base64
import httpx
import secrets
import bcrypt
import traceback
from datetime import datetime
from typing import Optional, Dict, List, Any
from fastapi import HTTPException, Request
from fastapi.responses import RedirectResponse, JSONResponse
from pydantic import BaseModel

# Try to import Github library
try:
    from github import Github, GithubException, InputGitTreeElement
    GITHUB_LIB_AVAILABLE = True
except ImportError:
    GITHUB_LIB_AVAILABLE = False
    print("WARNING: PyGithub not installed. GitHub features disabled.")
    print("Run: pip install PyGithub")

# ============================================================================
# CONFIGURATION
# ============================================================================

GITHUB_CLIENT_ID = os.environ.get("GITHUB_CLIENT_ID", "")
GITHUB_CLIENT_SECRET = os.environ.get("GITHUB_CLIENT_SECRET", "")
GITHUB_REDIRECT_URI = os.environ.get("GITHUB_REDIRECT_URI", "http://localhost:8000/auth/github/callback")

# GitHub OAuth URLs
GITHUB_AUTH_URL = "https://github.com/login/oauth/authorize"
GITHUB_TOKEN_URL = "https://github.com/login/oauth/access_token"
GITHUB_API_URL = "https://api.github.com"

# ============================================================================
# PYDANTIC MODELS
# ============================================================================

class GitHubUser(BaseModel):
    id: int
    login: str
    email: Optional[str] = None
    avatar_url: str = ""
    name: Optional[str] = None
    access_token: str

class DeployRequest(BaseModel):
    repo_name: str
    description: Optional[str] = "Generated by Nexus AI Code Builder"
    is_private: bool = False
    enable_pages: bool = True

class FileContent(BaseModel):
    path: str
    content: str
    encoding: str = "utf-8"

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def generate_nexus_key() -> str:
    """Generate unique API key"""
    return f"nx-{secrets.token_hex(16)}"

def get_current_user_email(request: Request) -> Optional[str]:
    """Get current logged-in user email from session"""
    return request.session.get("user_email")

# ============================================================================
# GITHUB OAUTH FUNCTIONS
# ============================================================================

def get_github_auth_url(state: str = "") -> str:
    """Generate GitHub OAuth authorization URL"""
    if not GITHUB_CLIENT_ID:
        raise HTTPException(status_code=500, detail="GitHub OAuth not configured - missing CLIENT_ID")

    params = {
        "client_id": GITHUB_CLIENT_ID,
        "redirect_uri": GITHUB_REDIRECT_URI,
        "scope": "repo user email",
        "state": state,
        "allow_signup": "true"
    }

    query = "&".join([f"{k}={v}" for k, v in params.items()])
    return f"{GITHUB_AUTH_URL}?{query}"

async def exchange_code_for_token(code: str) -> Dict:
    """Exchange OAuth code for access token"""
    async with httpx.AsyncClient() as client:
        response = await client.post(
            GITHUB_TOKEN_URL,
            headers={"Accept": "application/json"},
            data={
                "client_id": GITHUB_CLIENT_ID,
                "client_secret": GITHUB_CLIENT_SECRET,
                "code": code,
                "redirect_uri": GITHUB_REDIRECT_URI
            },
            timeout=10.0
        )

        if response.status_code != 200:
            raise HTTPException(status_code=400, detail="Failed to exchange code for token")

        data = response.json()
        if "error" in data:
            raise HTTPException(status_code=400, detail=data.get("error_description", "OAuth error"))

        return data

async def get_github_user(access_token: str) -> GitHubUser:
    """Fetch GitHub user info using access token"""
    async with httpx.AsyncClient() as client:
        user_response = await client.get(
            f"{GITHUB_API_URL}/user",
            headers={
                "Authorization": f"token {access_token}",
                "Accept": "application/vnd.github.v3+json"
            }
        )

        if user_response.status_code != 200:
            raise HTTPException(status_code=400, detail="Failed to fetch user info")

        user_data = user_response.json()

        email_response = await client.get(
            f"{GITHUB_API_URL}/user/emails",
            headers={
                "Authorization": f"token {access_token}",
                "Accept": "application/vnd.github.v3+json"
            }
        )

        primary_email = None
        if email_response.status_code == 200:
            emails = email_response.json()
            primary = next((e for e in emails if e.get("primary")), None)
            primary_email = primary.get("email") if primary else emails[0].get("email") if emails else None

        return GitHubUser(
            id=user_data["id"],
            login=user_data["login"],
            email=primary_email,
            avatar_url=user_data.get("avatar_url", ""),
            name=user_data.get("name"),
            access_token=access_token
        )

# ============================================================================
# SESSION MANAGEMENT
# ============================================================================

def store_github_token(request: Request, token_data: Dict):
    """Store GitHub token in session"""
    request.session["github_token"] = token_data.get("access_token")
    request.session["github_scope"] = token_data.get("scope", "")
    request.session["github_token_type"] = token_data.get("token_type", "bearer")

def get_github_token(request: Request) -> Optional[str]:
    """Retrieve GitHub token from session"""
    return request.session.get("github_token")

def clear_github_session(request: Request):
    """Clear GitHub session data"""
    keys = ["github_token", "github_scope", "github_token_type", "oauth_state"]
    for key in keys:
        request.session.pop(key, None)

def is_github_connected(request: Request) -> bool:
    """Check if user has connected GitHub account"""
    return bool(get_github_token(request))

# ============================================================================
# DATABASE HELPERS (Avoid circular imports)
# ============================================================================

def get_user_by_email_safe(email: str) -> Optional[Dict]:
    """Safely try to get user from database"""
    try:
        # Dynamic import to avoid circular imports
        from database import get_user_by_email
        return get_user_by_email(email)
    except Exception as e:
        print(f"[GitHub] Warning: Could not check user in DB: {e}")
        return None

def create_user_record_safe(email: str, password_hash: str, api_key: str) -> bool:
    """Safely try to create user in database"""
    try:
        from database import create_user_record
        return create_user_record(email, password_hash, api_key)
    except Exception as e:
        print(f"[GitHub] Warning: Could not create user in DB: {e}")
        return False

def store_github_info_safe(email: str, login: str, avatar: str, token: str):
    """Safely store GitHub info in Redis"""
    try:
        from database import redis
        if redis:
            redis.hset(f"github:{email}", mapping={
                "login": login,
                "avatar": avatar,
                "token": token
            })
    except Exception as e:
        print(f"[GitHub] Warning: Could not store in Redis: {e}")

# ============================================================================
# AUTHENTICATION HANDLERS
# ============================================================================

async def handle_github_login(request: Request):
    """Initiate GitHub OAuth flow"""
    try:
        print("[GitHub OAuth] Starting login process...")

        if not GITHUB_CLIENT_ID:
            print("[GitHub OAuth] ERROR: GITHUB_CLIENT_ID not configured")
            return RedirectResponse("/auth?error=github_not_configured")

        state = secrets.token_urlsafe(32)
        request.session["oauth_state"] = state

        print(f"[GitHub OAuth] Generated state: {state}")

        auth_url = get_github_auth_url(state)
        print(f"[GitHub OAuth] Redirecting to: {auth_url[:80]}...")

        return RedirectResponse(auth_url)

    except Exception as e:
        print(f"[GitHub OAuth] CRITICAL ERROR in handle_github_login: {str(e)}")
        print(traceback.format_exc())
        return RedirectResponse(f"/auth?error=server_error&message={str(e)}")

async def handle_github_callback(request: Request, code: str, state: str):
    """Handle GitHub OAuth callback"""
    try:
        print(f"[GitHub OAuth] Callback received. Code: {code[:10]}..., State: {state}")

        saved_state = request.session.get("oauth_state")
        print(f"[GitHub OAuth] Saved state: {saved_state}")

        # For Replit testing: skip state check or just warn
        if not saved_state:
            print("[GitHub OAuth] WARNING: No saved state found (Replit session issue)")
            # Continue anyway for testing
        elif saved_state != state:
            print(f"[GitHub OAuth] WARNING: State mismatch (expected {saved_state}, got {state})")
            # Continue anyway for testing in Replit

        # Clear state
        request.session.pop("oauth_state", None)

        # Exchange code for token
        try:
            token_data = await exchange_code_for_token(code)
        except Exception as e:
            print(f"[GitHub OAuth] Token exchange failed: {e}")
            return RedirectResponse(f"/auth?error=token_exchange_failed")

        access_token = token_data.get("access_token")
        if not access_token:
            print("[GitHub OAuth] ERROR: No access token in response")
            return RedirectResponse("/auth?error=no_access_token")

        print("[GitHub OAuth] Got access token, fetching user info...")

        # Get user info
        try:
            github_user = await get_github_user(access_token)
        except Exception as e:
            print(f"[GitHub OAuth] Failed to get user info: {e}")
            return RedirectResponse(f"/auth?error=user_info_failed")

        print(f"[GitHub OAuth] User: {github_user.login}, Email: {github_user.email}")

        # Determine email
        email = github_user.email or f"{github_user.login}@github.user"

        # Check if user exists
        existing_user = get_user_by_email_safe(email)

        if existing_user:
            print(f"[GitHub OAuth] Existing user found: {email}")
            request.session["user_email"] = email
            store_github_token(request, token_data)
            store_github_info_safe(email, github_user.login, github_user.avatar_url, access_token)
            return RedirectResponse("/dashboard?github_connected=true")
        else:
            print(f"[GitHub OAuth] Creating new user: {email}")
            # Create new user
            new_key = generate_nexus_key()
            temp_password = secrets.token_urlsafe(16)
            hashed = bcrypt.hashpw(
                temp_password.encode('utf-8'), 
                bcrypt.gensalt(rounds=12)
            ).decode('utf-8')

            user_created = create_user_record_safe(email, hashed, new_key)

            if user_created:
                request.session["user_email"] = email
                store_github_token(request, token_data)
                store_github_info_safe(email, github_user.login, github_user.avatar_url, access_token)
                print("[GitHub OAuth] New user created successfully")
                return RedirectResponse("/dashboard?github_connected=true&new_user=true")
            else:
                print("[GitHub OAuth] ERROR: Failed to create user")
                # Still try to log them in anyway for demo purposes
                request.session["user_email"] = email
                store_github_token(request, token_data)
                return RedirectResponse("/dashboard?github_connected=true&demo=true")

    except Exception as e:
        print(f"[GitHub OAuth] CRITICAL ERROR in callback: {str(e)}")
        print(traceback.format_exc())
        return RedirectResponse(f"/auth?error=callback_error&message={str(e)}")

async def handle_github_logout(request: Request):
    """Disconnect GitHub account"""
    try:
        clear_github_session(request)
        return JSONResponse({"message": "GitHub disconnected successfully"})
    except Exception as e:
        print(f"[GitHub OAuth] Error in logout: {e}")
        return JSONResponse({"error": str(e)}, status_code=500)

def get_github_context(request: Request) -> dict:
    """Get GitHub connection status for templates"""
    try:
        token = get_github_token(request)
        is_connected = bool(token)

        context = {
            "github_connected": is_connected,
            "github_login_url": "/auth/github/login",
            "github_disconnect_url": "/auth/github/logout"
        }

        # Try to get user info if connected
        if is_connected:
            email = get_current_user_email(request)
            if email:
                try:
                    from database import redis
                    if redis:
                        gh_info = redis.hgetall(f"github:{email}")
                        if gh_info:
                            context["github_user"] = {
                                "login": gh_info.get(b"login", b"").decode() if isinstance(gh_info.get(b"login"), bytes) else gh_info.get("login", ""),
                                "avatar": gh_info.get(b"avatar", b"").decode() if isinstance(gh_info.get(b"avatar"), bytes) else gh_info.get("avatar", "")
                            }
                except Exception as e:
                    print(f"[GitHub] Could not get user context: {e}")

        return context
    except Exception as e:
        print(f"[GitHub] Error getting context: {e}")
        return {
            "github_connected": False,
            "github_login_url": "/auth/github/login",
            "github_disconnect_url": "/auth/github/logout"
        }

# ============================================================================
# REPOSITORY OPERATIONS
# ============================================================================

class GitHubDeployer:
    """Handle repository creation and file deployment"""

    def __init__(self, access_token: str):
        if not GITHUB_LIB_AVAILABLE:
            raise Exception("PyGithub not installed")
        self.g = Github(access_token)
        self.user = self.g.get_user()

    def create_repository(self, name: str, description: str = "", private: bool = False) -> Dict:
        """Create a new repository"""
        try:
            try:
                existing = self.user.get_repo(name)
                return {
                    "success": False,
                    "error": "Repository already exists",
                    "repo_url": existing.html_url,
                    "exists": True
                }
            except GithubException:
                pass

            repo = self.user.create_repo(
                name=name,
                description=description,
                private=private,
                auto_init=True,
                gitignore_template="Node"
            )

            return {
                "success": True,
                "repo_name": repo.name,
                "repo_url": repo.html_url,
                "clone_url": repo.clone_url,
                "ssh_url": repo.ssh_url,
                "default_branch": repo.default_branch
            }

        except GithubException as e:
            return {
                "success": False,
                "error": str(e.data.get("message", "Unknown error")),
                "status": e.status
            }

    def deploy_files(self, repo_name: str, files: List[FileContent], 
                     commit_message: str = "Initial commit from Nexus AI") -> Dict:
        """Deploy multiple files to repository"""
        try:
            repo = self.user.get_repo(repo_name)
            default_branch = repo.default_branch
            base_tree = repo.get_git_tree(default_branch)

            tree_elements = []
            for file in files:
                if file.encoding == "base64":
                    content = file.content
                else:
                    content = base64.b64encode(file.content.encode()).decode()

                blob = repo.create_git_blob(content, "base64")
                element = InputGitTreeElement(
                    path=file.path,
                    mode="100644",
                    type="blob",
                    sha=blob.sha
                )
                tree_elements.append(element)

            new_tree = repo.create_git_tree(tree_elements, base_tree)
            parent = repo.get_git_commit(base_tree.sha)

            commit = repo.create_git_commit(
                message=commit_message,
                tree=new_tree,
                parents=[parent]
            )

            ref = repo.get_git_ref(f"heads/{default_branch}")
            ref.edit(commit.sha)

            return {
                "success": True,
                "commit_sha": commit.sha,
                "files_count": len(files),
                "branch": default_branch
            }

        except GithubException as e:
            return {
                "success": False,
                "error": str(e.data.get("message", "Unknown error"))
            }

    def enable_github_pages(self, repo_name: str, branch: str = "main", path: str = "/") -> Dict:
        """Enable GitHub Pages for the repository"""
        try:
            repo = self.user.get_repo(repo_name)

            try:
                repo.create_pages_source(branch=branch, path=path)
            except:
                pass

            pages_url = f"https://{self.user.login}.github.io/{repo_name}/"

            return {
                "success": True,
                "pages_url": pages_url,
                "status": "enabled"
            }

        except GithubException as e:
            if e.status == 409:
                return {
                    "success": True,
                    "pages_url": f"https://{self.user.login}.github.io/{repo_name}/",
                    "status": "already_enabled"
                }
            return {
                "success": False,
                "error": str(e.data.get("message", "Failed to enable Pages"))
            }

    def get_repos(self, per_page: int = 10) -> List[Dict]:
        """Get user's repositories"""
        try:
            repos = self.user.get_repos(sort="updated", direction="desc")[:per_page]
            return [{
                "name": r.name,
                "full_name": r.full_name,
                "description": r.description,
                "private": r.private,
                "html_url": r.html_url,
                "updated_at": r.updated_at.isoformat() if r.updated_at else None,
                "stargazers_count": r.stargazers_count
            } for r in repos]
        except GithubException as e:
            return []

# ============================================================================
# ONE-CLICK DEPLOY HELPER
# ============================================================================

async def one_click_deploy(
    access_token: str,
    project_name: str,
    files: List[Dict[str, str]],
    description: str = "",
    is_private: bool = False,
    enable_pages: bool = True
) -> Dict:
    """Complete one-click deployment flow"""
    if not GITHUB_LIB_AVAILABLE:
        return {"success": False, "error": "PyGithub not installed"}

    try:
        deployer = GitHubDeployer(access_token)

        safe_name = "".join(c if c.isalnum() or c in "-_" else "-" for c in project_name.lower())
        safe_name = safe_name.strip("-")

        repo_result = deployer.create_repository(safe_name, description, is_private)

        if not repo_result["success"] and not repo_result.get("exists"):
            return repo_result

        repo_url = repo_result["repo_url"]

        file_objects = [
            FileContent(path=f["path"], content=f["content"])
            for f in files
        ]

        deploy_result = deployer.deploy_files(safe_name, file_objects)

        if not deploy_result["success"]:
            return {
                "success": False,
                "stage": "deploy_files",
                "error": deploy_result["error"],
                "repo_url": repo_url
            }

        pages_result = None
        if enable_pages:
            pages_result = deployer.enable_github_pages(safe_name)

        return {
            "success": True,
            "repo_url": repo_url,
            "pages_url": pages_result.get("pages_url") if pages_result else None,
            "pages_enabled": pages_result.get("success", False) if pages_result else False,
            "commit_sha": deploy_result.get("commit_sha"),
            "files_deployed": deploy_result.get("files_count")
        }
    except Exception as e:
        print(f"[GitHub Deploy] Error: {e}")
        print(traceback.format_exc())
        return {"success": False, "error": str(e)}
